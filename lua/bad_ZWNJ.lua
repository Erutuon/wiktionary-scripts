local data_by_title = require "data_by_title" "templates"
local iterate_templates = require "iterate_templates"
local rure = require "luarure"
local Array = require "mediawiki.array"

local chars_from_names = require "utils".chars_from_names

local ZWNJ = chars_from_names("zero width non-joiner")

local iter_prev_char
do
	local max_UTF8_bytes = 4
	function iter_prev_char(str, pos)
		return coroutine.wrap(function ()
			pos = pos - 1
			while pos >= 1 do
				local char = str:sub(math.max(pos - max_UTF8_bytes, 0), pos):match(utf8.charpattern .. "$")
				if char == "" then
					break
				end
				pos = pos - #char + 1
				coroutine.yield(char)
			end
		end)
	end
end

local function iter_next_char(str, pos)
	return coroutine.wrap(function ()
		while true do
			local char
			char, pos = str:match("^(" .. utf8.charpattern .. ")()", pos)
			if not char then
				break
			end
			coroutine.yield(char)
		end
	end)
end

local next_bad_ZWNJ
do
	-- Rules based on https://www.unicode.org/reports/tr31/tr31-31.html#A1
	
	-- Regex generated by https://unicode.org/cldr/utility/list-unicodeset.jsp
	-- with C-style escapes converted to Rust-style escapes.
	-- [[\p{Joining_Type=Dual_Joining}\p{Joining_Type=Left_Joining}]&\p{Script=Arabic}]
	local Arabic_left_joining = rure.new "[Ø¦à¢¨à¢©Ù®Ø¨Ù»Ù¾Ú€Ý-Ý•à¢ Ý–à¢¡à¢¶à¢·ØªØ«Ù¹ÙºÙ¼Ù½Ù¿à¢¸Ø¬ÚƒÚ„Ú†Ú¿Ú‡à¢¢Ø­Ø®ÚÚ‚Ú…Ý—Ý˜Ý®Ý¯Ý²Ý¼Ø³Ø´Úš-ÚœÛºÝœÝ­Ý°Ý½Ý¾ØµØ¶Úà¢¯ÚžÛ»Ø·Ø¸ÚŸà¢£Ø¹ØºÚ Û¼Ý-ÝŸà¢³ÙÚ¡Ú¢à¢»Ú£Ú¤à¢¤Ú¥Ú¦Ý Ý¡Ù¯Ù‚Ú§à¢¼Ú¨à¢¥ÙƒÚ©-Ú¬Ý¿Ú­Ú®à¢´Ú¯à¢°Ú°-Ú´Ý¢Ø»Ø¼Ý£Ý¤Ù„Úµ-Ú¸Ýªà¢¦Ù…Ý¥Ý¦à¢§Ù†Úºà¢½Ú»-Ú½Ú¹Ý§-Ý©Ù‡Ú¾ÛÛ‚Û¿Ù‰ÙŠÙ¸ÛŒÛŽÛÛ‘Ø½-Ø¿Ø Ýµ-Ý·à¢ºÝºÝ»]"
	
	-- [[\p{Joining_Type=Dual_Joining}\p{Joining_Type=Right_Joining}]&\p{Script=Arabic}]
	local Arabic_right_joining = rure.new "[Ø¢Ø£Ù²Ù±Ø¤Ø¥Ù³Ý³Ý´Ø¦à¢¨à¢©à¢¬Ø§ÙµÙ®Ø¨Ù»Ù¾Ú€Ý-Ý•à¢ Ý–à¢¡à¢¶à¢·Ø©-Ø«Ù¹ÙºÙ¼Ù½Ù¿à¢¸Ø¬ÚƒÚ„Ú†Ú¿Ú‡à¢¢Ø­Ø®ÚÚ‚Ú…Ý—Ý˜Ý®Ý¯Ý²Ý¼Ø¯Ø°Úˆ-Úà¢®ÚŽ-ÚÛ®Ý™ÝšØ±Ø²Ú‘-Ú™Û¯Ý›Ý«Ý¬Ý±à¢ªà¢²à¢¹Ø³Ø´Úš-ÚœÛºÝœÝ­Ý°Ý½Ý¾ØµØ¶Úà¢¯ÚžÛ»Ø·Ø¸ÚŸà¢£Ø¹ØºÚ Û¼Ý-ÝŸà¢³ÙÚ¡Ú¢à¢»Ú£Ú¤à¢¤Ú¥Ú¦Ý Ý¡Ù¯Ù‚Ú§à¢¼Ú¨à¢¥ÙƒÚ©-Ú¬Ý¿Ú­Ú®à¢´Ú¯à¢°Ú°-Ú´Ý¢Ø»Ø¼Ý£Ý¤Ù„Úµ-Ú¸Ýªà¢¦Ù…Ý¥Ý¦à¢§Ù†Úºà¢½Ú»-Ú½Ú¹Ý§-Ý©Ù‡Ú¾Û-ÛƒÛ¿Û•Û€ÙˆÙ¶Û„-Û‡Ù·Ûˆ-Û‹à¢±ÛÝ¸Ý¹à¢«Ù‰ÙŠÙ¸ÛŒ-ÛŽÛÛ‘Ø½-Ø¿Ø Ýµ-Ý·à¢ºÛ’Û“ÝºÝ»]"
	
	-- \p{Joining_Type=Transparent}
	local transparent = rure.new "[\u{00AD}\u{034F}ÒˆÒ‰Ö‘-Ö¯Ö½×„×…Ø-Øš\u{061C}Û–-ÛœÛŸ-Û¤Û§Û¨Ûª-Û­\u{070F}Ý€ÝƒÝ„Ý‡-ÝŠà£“-à£¡à£ª-à£¯à£³à¥‘à¥’à¼˜à¼™à¼µà¼·à¾‚à¾ƒà¾†à¾‡à¿†\u{17B4}\u{17B5}áŸ“\u{180B}-\u{180D}á©¿á­«-á­³á³-á³’á³”-á³ á³¢-á³¨á³´á³¸á³¹\u{200B}\u{200E}\u{200F}\u{202A}-\u{202E}\u{2060}-\u{2064}\u{206A}-\u{206F}âµ¿ê™°-ê™²ê£ -ê£±\u{FE00}-ï¸ï¸¡ï¸£-ï¸¦ï¸¨ï¸ª-ï¸­ï¸¯\u{FEFF}\u{FFF9}-\u{FFFB}ð‹ ð‘¦-ð‘¬ð‘°-ð‘´\u{13430}-\u{13438}\u{1BCA0}-\u{1BCA3}ð…§-ð…©\u{1D173}-ð†‚ð†…-ð†‹ð†ª-ð†­ð‰‚-ð‰„ð¨€-ð¨¶ð¨»-ð©¬ð©µðª„ðª›-ðªŸðª¡-ðª¯ðž£-ðž£–\u{E0001}\u{E0020}-\u{E007F}\u{E0100}-\u{E01EF}Ì²Ì“ÍƒÒ†â³±Ì”Ò…â³°ÌÍà¥”Ì€Í€à¥“Ì†Ì‚ÌŒÌŠÍ‚ÌˆÍ„Ì‹ÌƒÌ‡Ì¸Ì§Ì¨Ì„ÌÌŽÌ’Ì•ÌšÌ½-Ì¿Í†ÍŠ-ÍŒÍ-Í’Í—Í›ÍÍžÒ„Ò‡ÝÝ…áŸ‹-áŸ‘áŸáª°-áª´áª»áª¼á·€á·á·ƒ-á·‰á·‹-á·Žá·‘á·µ-á·¸á·»á·¾âƒ°â³¯ê™¼ê™½ð«¥ð´¤-ð´§ð½ˆ-ð½Šð½Œð›²Ì–-Ì™Ìœ-Ì Ì©-Ì¬Ì¯Ì³Ìº-Ì¼Í‡-Í‰ÍÍŽÍ“-Í–Í™ÍšÍœÍŸÍ¢Ý‚Ý†ß½à¡™-à¡›áªµ-áªºáª½á·‚á·á·á·¹á·¼á·½á·¿âƒ¬-âƒ¯ï¸§ð¨ð«¦ð½†ð½‡ð½‹ð½-ð½Ì¶Ì·âƒ˜-âƒšâƒ¥âƒªâƒ«ð›²žáª¾âƒ-âƒ âƒ¢-âƒ¤ã‚™ã‚šÌµÌ…Ì‰Ì-Ì‘Ì›Ì¡-Ì¦Ì­Ì®Ì°Ì±Ì´Ì¹Í…Í˜Í ï¸¢ï¸©Í¡ï¸ Òƒï¸®ê™¯Ö°-Ö¸×‡Ö¹-Ö»×‚×Ö¼Ö¿ï¬žà œ-à £à ¥-à §à ©-à ¬à ˜à ™à ­Ù‹à£°à£§ÙŒà£±à£¨Ùà£²à£©ÙŽà£¤à£´à£µÙà£¥à£¾Ùà£¦à£¶Ù‘à«»ð‘ˆ·Ù’à«ºð‘ˆ¾Ù“à«¼Ù”Ù•ÙŸÙ–-Ù˜à£¿Ù™-Ùžà££à£·à£¸à£½à£»à£¼à£¹à£ºÙ°Ü‘Ü°-Ü¿ß«-ß³áŸážáê›°ê›±ð–«°-ð–«´ðž¥„-ðž¥†ðž¥Šðž¥‡-ðž¥‰à¤¼à¦¼à¨¼àª¼à«½-à«¿à¬¼à²¼á¬´á¯¦á°·ê¦³ð‘‚ºð‘…³ð‘‡Šð‘ˆ¶ð‘‹©ð‘Œ»ð‘Œ¼ð‘‘†ð‘“ƒð‘—€ð‘š·ð‘ ºð‘¨³ð‘µ‚à¤€à¤à¦à¨àªà¬à°€à²à´á¬€á¬ê£…ê¦€ð‘‚€ð‘„€ð‘†€ð‘Œð‘‘ƒð‘’¿ð‘–¼ð‘™€ð‘¨µ-ð‘¨·ð‘°¼ð‘²¶ð‘µƒà¤‚à¨‚àª‚à®‚à°„à´€à½¾á€¶áŸ†á©´á¬‚á®€á³­ê ‹ê¦ð¨Žð‘€ð‘‚ð‘„ð‘†ð‘ˆ´ð‘‹Ÿð‘Œ€ð‘‘„ð‘“€ð‘–½ð‘˜½ð‘š«ð‘ ·ð‘¨¸ð‘ª–ð‘°½ð‘²µð‘µ€ð‘¶•ð¨ð‘„‚ð‘µà§¾ð‘‡‰ð‘‘žà©°à©±á¬ƒê¦‚á®ð¨¸-ð¨ºð‘‡‹ð‘‡Œð‘ª˜à¹Žà¹‡-à¹à»ˆ-à»êª¿ê«à¼¹ê¤«-ê¤­á€·áŸ‰áŸŠá©µ-á©¼á¤¹-á¤»ð–¬°ðž„±ð–¬±ðž„¶ð–¬²ðž„²ð–¬³ðž„³ð–¬´ðž„°ð–¬µðž„´ð–¬¶ðž„µðž‹¬-ðž‹¯ã€ª-ã€­âƒ-âƒ—âƒ›âƒœâƒ¡âƒ¦-âƒ©ð‡½Í£á·²á·“-á·–á·§-á·©Í¨á·—Í©á·™á·˜Í¤á·ªá·«á·šá·›ÍªÍ¥á·œ-á·žá·¬Í«á·Ÿ-á·¡Í¦á·³á·­á·®Í¬á·Šá·¢-á·¥á·¯Í­Í§á·´á·°Í®á·±Í¯á·¦á·’â·¶â· -â·£â··ê™´â·¤â·¥ê™µê™¶â·¸â·¦-â·­â·µâ·®ê™·â·¹êšžâ·¯ê™»â·°-â·³ê™¸-ê™ºâ·º-â·¼êšŸâ·½-â·¿â·´ðž€€-ðž€†ðž€ˆ-ðž€˜ðž€›-ðž€¡ðž€£ðž€¤ðž€¦-ðž€ªð¶-ðºà –à —à ›Þ¦-Þ°à¤ºà¥–à¥—à¥-à¥„à¥¢à¥£à¥…à¥•à¥†-à¥ˆê£¿à¥à§-à§„à§¢à§£à§à©‘à©µà©à©‚à©‡à©ˆà©‹-à©à«-à«„à«¢à«£à«…à«‡à«ˆà«à¬¿à­-à­„à­¢à­£à­à­–à¯€à¯à°¾-à±€à±¢à±£à±†-à±ˆà±Š-à±à±•à±–à²¿à³¢à³£à³†à³Œà³àµ-àµ„àµ¢àµ£àµà´»à´¼à·’-à·”à·–à·Šê¯¥ê¯¨ê«¬ê«­ê¯­ê«¶ê ‚ê †ê ¥ê ¦ê£„ð‘‚³-ð‘‚¶ð‘‚¹ð‘†¶-ð‘†¾ð‘ˆ¯-ð‘ˆ±ð‘‹£-ð‘‹¨ð‘‹ªð‘€ð‘¸-ð‘¿ð‘‘‚ð‘’³-ð‘’¸ð‘’ºð‘“‚ð‘–²ð‘—œð‘–³ð‘—ð‘–´ð‘–µð‘–¿ð‘˜³-ð‘˜ºð‘˜¿ð‘š­ð‘š°-ð‘šµð‘§”-ð‘§—ð‘§šð‘§›ð‘§ ð‘ ¯-ð‘ ¶ð‘ ¹ð‘œ¢-ð‘œ¥ð‘œ§-ð‘œ«ð‘œ-ð‘œŸð‘µ‡ð‘´±-ð‘´¶ð‘´ºð‘´¼ð‘´½ð‘´¿ð‘µ„ð‘µ…ð‘¶ð‘¶‘ð‘¶—á®¬á®¢á®£á®­á®¤á®¥á®¨á®©á®«ð‘€¸-ð‘†ð‘¿ð¨-ð¨ƒð¨…ð¨†ð¨Œð¨¿ð‘°°-ð‘°¶ð‘°¸-ð‘°»ð‘°¿à¸±à¸´-à¸ºàº±àº´-àº¼êª°êª²-êª´êª·êª¸êª¾à¾à¾¹à¾‘-à¾—à¾™-à¾­à¾ºà¾®-à¾±à¾»à¾²à¾¼à¾³-à¾¸à¾-à¾à½±-à½³à¾€à¾à½´-à½½à¾„ð‘¨»-ð‘¨¾ð‘¨-ð‘¨Šð‘¨´ð‘©‡ð‘©‘-ð‘©“ð‘©™ð‘©šð‘©”ð‘©–ð‘©•ð‘©›ð‘ªŠ-ð‘ªð‘ª•ð‘ª‘-ð‘ª”ð‘ª™ð‘²’-ð‘²§ð‘²ª-ð‘²°ð‘²²ð‘²³á°¶á°¬-á°³á¤ -á¤¢á¤§á¤¨á¤²áœ’-áœ”áœ²-áœ´á’á“á²á³á¨—á¨˜á¨›ð‘»³ð‘»´á¯¨á¯©á¯­á¯¯-á¯±ê¥‡-ê¥‘ê¤¦-ê¤ªáž-á á€½á‚‚á€¾á²á€­á±á€®á€³á€¯á³á´á€°á˜á™á€µá‚…á€²á‚á€´ê§¥á‚†á€¹á€ºá‚ê©¼ð‘„§-ð‘„«ð‘„­-ð‘„´áž·-áž½áŸ’á©˜-á©›á©«á©–á©œ-á©žá©¬á©¢á©¥-á©ªá©³á© ê¨µê¨¶ê¨©-ê¨®ê¨±ê¨²ê©ƒê©Œá¬¶-á¬ºá¬¼á­‚ê¦¼ê¦¶-ê¦¹ê¦½á¢…á¢†á¢©ðž¥‹ð–½ð–¾-ð–¾’]"
	
	function next_bad_ZWNJ(str, pos)
		pos = pos or 1
		return coroutine.wrap(function ()
			while true do
				local next_pos = str:find(ZWNJ, pos)
				if not next_pos then
					break
				end
				
				local found_left_joining, found_right_joining = false, false
				for char in iter_prev_char(str, next_pos) do
					if Arabic_left_joining:is_match(char) then
						found_left_joining = true
						break
					elseif not transparent:is_match(char) then
						break
					end
				end
				
				for char in iter_next_char(str, next_pos + #ZWNJ) do
					if Arabic_right_joining:is_match(char) then
						found_right_joining = true
						break
					elseif not transparent:is_match(char) then
						break
					end
				end
				
				if not (found_left_joining and found_right_joining) then
					coroutine.yield(next_pos)
					goto continue
				end
				
				::continue::
				pos = next_pos + #ZWNJ
			end
		end)
	end
end

local function collect(iter)
	local vals = Array()
	for val in iter do
		vals:insert(val)
	end
	return vals
end

local count = 0
local limit = type((...)) == "string" and tonumber(...) or math.huge

local Arabic_regex = rure.new "\\p{Arabic}"

--[[
for link, title, template in iterate_templates.iterate_links(assert(io.read 'a')) do
	if ((link.term and Arabic_regex:is_match(link.term) and next_bad_ZWNJ(link.term)() ~= nil)
			or (link.alt and Arabic_regex:is_match(link.alt) and next_bad_ZWNJ(link.alt)() ~= nil)) then
		data_by_title[title]:insert(template.text)
		
		count = count + 1
		if count > limit then
			break
		end
	end
end
--]]

for namespace, title in assert(io.read 'a'):gmatch('%f[^\n\0](%d)\t([^\n]+)') do
	if namespace == "0" and Arabic_regex:is_match(title) and next_bad_ZWNJ(title)() ~= nil then
		title = title:gsub("_", " ")
		print('* <span class="Arab">[[' .. title .. '|' .. title
			.. ']]</span> (<span class="Arab">'
			.. title:gsub(ZWNJ, '<span dir="ltr">&amp;zwnj;</span>') .. '</span>)')
	end
end